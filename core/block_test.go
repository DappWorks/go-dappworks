// Copyright (C) 2018 go-dappley authors
//
// This file is part of the go-dappley library.
//
// the go-dappley library is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// the go-dappley library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with the go-dappley library.  If not, see <http://www.gnu.org/licenses/>.
//

package core

import (
	"testing"
	"time"

	"github.com/dappley/go-dappley/core/pb"
	"github.com/gogo/protobuf/proto"
	"github.com/stretchr/testify/assert"
)

var header = &BlockHeader{
	hash:      []byte{},
	prevHash:  []byte{},
	nonce:     0,
	timestamp: time.Now().Unix(),
}
var blk = &Block{
	header: header,
}

var expect = []byte{0x42, 0xff, 0x81, 0x3, 0x1, 0x1, 0xb, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x1, 0xff, 0x82, 0x0, 0x1, 0x3, 0x1, 0x6, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x1, 0xff, 0x84, 0x0, 0x1, 0xc, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1, 0xff, 0x90, 0x0, 0x1, 0x6, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x1, 0x6, 0x0, 0x0, 0x0, 0x4d, 0xff, 0x83, 0x3, 0x1, 0x1, 0x11, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x1, 0xff, 0x84, 0x0, 0x1, 0x4, 0x1, 0x4, 0x48, 0x61, 0x73, 0x68, 0x1, 0xa, 0x0, 0x1, 0x8, 0x50, 0x72, 0x65, 0x76, 0x48, 0x61, 0x73, 0x68, 0x1, 0xa, 0x0, 0x1, 0x5, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x1, 0x4, 0x0, 0x1, 0x9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x1, 0x4, 0x0, 0x0, 0x0, 0x22, 0xff, 0x8f, 0x2, 0x1, 0x1, 0x13, 0x5b, 0x5d, 0x2a, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x1, 0xff, 0x90, 0x0, 0x1, 0xff, 0x86, 0x0, 0x0, 0x2e, 0xff, 0x85, 0x3, 0x1, 0x2, 0xff, 0x86, 0x0, 0x1, 0x4, 0x1, 0x2, 0x49, 0x44, 0x1, 0xa, 0x0, 0x1, 0x3, 0x56, 0x69, 0x6e, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x4, 0x56, 0x6f, 0x75, 0x74, 0x1, 0xff, 0x8e, 0x0, 0x1, 0x3, 0x54, 0x69, 0x70, 0x1, 0x4, 0x0, 0x0, 0x0, 0x1d, 0xff, 0x89, 0x2, 0x1, 0x1, 0xe, 0x5b, 0x5d, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x54, 0x58, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x1, 0xff, 0x8a, 0x0, 0x1, 0xff, 0x88, 0x0, 0x0, 0x40, 0xff, 0x87, 0x3, 0x1, 0x1, 0x7, 0x54, 0x58, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x1, 0xff, 0x88, 0x0, 0x1, 0x4, 0x1, 0x4, 0x54, 0x78, 0x69, 0x64, 0x1, 0xa, 0x0, 0x1, 0x4, 0x56, 0x6f, 0x75, 0x74, 0x1, 0x4, 0x0, 0x1, 0x9, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x1, 0xa, 0x0, 0x1, 0x6, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x1, 0xa, 0x0, 0x0, 0x0, 0x1e, 0xff, 0x8d, 0x2, 0x1, 0x1, 0xf, 0x5b, 0x5d, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x54, 0x58, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x1, 0xff, 0x8e, 0x0, 0x1, 0xff, 0x8c, 0x0, 0x0, 0x2f, 0xff, 0x8b, 0x3, 0x1, 0x1, 0x8, 0x54, 0x58, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x1, 0xff, 0x8c, 0x0, 0x1, 0x2, 0x1, 0x5, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1, 0x4, 0x0, 0x1, 0xa, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x48, 0x61, 0x73, 0x68, 0x1, 0xa, 0x0, 0x0, 0x0, 0x13, 0xff, 0x82, 0x1, 0x2, 0x1, 0x61, 0x2, 0xfc, 0xb6, 0xb2, 0x24, 0x6a, 0x0, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0}
var expectHash = []uint8([]byte{0xff, 0xc1, 0x71, 0x5c, 0xce, 0x28, 0x40, 0xf, 0x9, 0xf4, 0xc1, 0xc8, 0x31, 0xdd, 0x58, 0xb, 0x1f, 0x5e, 0xa, 0xfb, 0xbc, 0x94, 0xcb, 0xe2, 0x60, 0x76, 0xf8, 0x73, 0x48, 0x3a, 0x60, 0xa0})
var header2 = &BlockHeader{
	hash:      []byte{'a'},
	prevHash:  []byte{'e', 'c'},
	nonce:     0,
	timestamp: time.Now().Unix(),
}
var blk2 = &Block{
	header: header2,
}

var header3 = &BlockHeader{
	hash:      []byte{'a'},
	prevHash:  []byte{'e', 'c'},
	nonce:     0,
	timestamp: 0,
}
var blk3 = &Block{
	header: header3,
}

func TestHashTransactions(t *testing.T) {
	block := NewBlock([]*Transaction{&Transaction{}}, blk2)
	hash := block.HashTransactions()
	assert.Equal(t, expectHash, hash)
}

func TestNewBlock(t *testing.T) {
	var emptyTransaction = []*Transaction([]*Transaction{})
	var emptyHash = Hash(Hash{})
	var expectBlock3Hash = Hash{0x61}
	block1 := NewBlock(nil, nil)
	assert.Nil(t, block1.header.prevHash)
	assert.Equal(t, emptyTransaction, block1.transactions)

	block2 := NewBlock(nil, blk)
	assert.Equal(t, emptyHash, block2.header.prevHash)
	assert.Equal(t, Hash(Hash{}), block2.header.prevHash)
	assert.Equal(t, emptyTransaction, block2.transactions)

	block3 := NewBlock(nil, blk2)
	assert.Equal(t, expectBlock3Hash, block3.header.prevHash)
	assert.Equal(t, Hash(Hash{'a'}), block3.header.prevHash)
	assert.Equal(t, []byte{'a'}[0], block3.header.prevHash[0])
	assert.Equal(t, uint64(1), block3.header.height)
	assert.Equal(t, emptyTransaction, block3.transactions)

	block4 := NewBlock([]*Transaction{}, nil)
	assert.Nil(t, block4.header.prevHash)
	assert.Equal(t, emptyTransaction, block4.transactions)
	assert.Equal(t, Hash(nil), block4.header.prevHash)

	block5 := NewBlock([]*Transaction{&Transaction{}}, nil)
	assert.Nil(t, block5.header.prevHash)
	assert.Equal(t, []*Transaction{&Transaction{}}, block5.transactions)
	assert.Equal(t, &Transaction{}, block5.transactions[0])
	assert.NotNil(t, block5.transactions)
}

func TestBlockHeader_Proto(t *testing.T) {
	bh1 := BlockHeader{
		[]byte("hash"),
		[]byte("hash"),
		1,
		2,
		nil,
		0,
	}

	pb := bh1.ToProto()
	var i interface{} = pb
	_, correct := i.(proto.Message)
	assert.Equal(t, true, correct)
	mpb, err := proto.Marshal(pb)
	assert.Nil(t, err)

	newpb := &corepb.BlockHeader{}
	err = proto.Unmarshal(mpb, newpb)
	assert.Nil(t, err)

	bh2 := BlockHeader{}
	bh2.FromProto(newpb)

	assert.Equal(t, bh1, bh2)
}

func TestBlock_Proto(t *testing.T) {

	b1 := GenerateMockBlock()

	pb := b1.ToProto()
	var i interface{} = pb
	_, correct := i.(proto.Message)
	assert.Equal(t, true, correct)
	mpb, err := proto.Marshal(pb)
	assert.Nil(t, err)

	newpb := &corepb.Block{}
	err = proto.Unmarshal(mpb, newpb)
	assert.Nil(t, err)

	b2 := &Block{}
	b2.FromProto(newpb)

	assert.Equal(t, *b1, *b2)
}

func TestBlock_VerifyHash(t *testing.T) {
	b1 := GenerateMockBlock()

	//The mocked block does not have correct hash value
	assert.False(t, b1.VerifyHash())

	//calculate correct hash value
	hash := b1.CalculateHash()
	b1.SetHash(hash)

	//then this should be correct
	assert.True(t, b1.VerifyHash())
}

func TestBlock_Rollback(t *testing.T) {
	b := GenerateMockBlock()
	tx := MockTransaction()
	b.transactions = []*Transaction{tx}
	txPool := NewTransactionPool()
	b.Rollback(txPool)
	assert.ElementsMatch(t, tx.ID, txPool.Transactions.Right().(Transaction).ID)
}

func TestBlock_FindTransaction(t *testing.T) {
	b := GenerateMockBlock()
	tx := MockTransaction()
	b.transactions = []*Transaction{tx}

	assert.Equal(t, tx.ID, b.FindTransactionById(tx.ID).ID)
}

func TestBlock_FindTransactionNilInput(t *testing.T) {
	b := GenerateMockBlock()
	assert.Nil(t, b.FindTransactionById(nil))
}

func TestBlock_FindTransactionEmptyBlock(t *testing.T) {
	b := GenerateMockBlock()
	tx := MockTransaction()
	assert.Nil(t, b.FindTransactionById(tx.ID))
}

func TestIsParentBlockHash(t *testing.T) {
	parentBlock := NewBlock([]*Transaction{&Transaction{}}, blk2)
	childBlock := NewBlock([]*Transaction{&Transaction{}}, parentBlock)

	assert.True(t, IsParentBlockHash(parentBlock, childBlock))
	assert.False(t, IsParentBlockHash(parentBlock, nil))
	assert.False(t, IsParentBlockHash(nil, childBlock))
	assert.False(t, IsParentBlockHash(childBlock, parentBlock))
}

func TestIsParentBlockHeight(t *testing.T) {
	parentBlock := NewBlock([]*Transaction{&Transaction{}}, blk2)
	childBlock := NewBlock([]*Transaction{&Transaction{}}, parentBlock)

	assert.True(t, IsParentBlockHeight(parentBlock, childBlock))
	assert.False(t, IsParentBlockHeight(parentBlock, nil))
	assert.False(t, IsParentBlockHeight(nil, childBlock))
	assert.False(t, IsParentBlockHeight(childBlock, parentBlock))
}
func TestCalculateHashWithNonce(t *testing.T) {
	block := NewBlock([]*Transaction{&Transaction{}}, blk3)
	block.header.timestamp = 0
	expectHash1 := Hash{0xea, 0x41, 0x77, 0xc1, 0x68, 0x5f, 0x34, 0x8c, 0x9d, 0x46, 0xed, 0xbd, 0x8b, 0x89, 0x21, 0xa4, 0x57, 0xf9, 0xec, 0x16, 0xa4, 0x9a, 0xff, 0x33, 0xb4, 0x3d, 0x5e, 0x33, 0x4d, 0x3b, 0xe4, 0x26}
	assert.Equal(t, Hash(expectHash1), block.CalculateHashWithNonce(1))
	expectHash2 := Hash{0xd, 0xb7, 0x2f, 0x29, 0xc8, 0x6b, 0xae, 0x2e, 0x2, 0x4c, 0xb9, 0x39, 0x72, 0x44, 0x6f, 0x44, 0xfe, 0xfc, 0xf6, 0x16, 0x60, 0x38, 0x8, 0xeb, 0x25, 0x34, 0x69, 0xc3, 0x7f, 0x2f, 0x87, 0x7a}
	assert.Equal(t, Hash(expectHash2), block.CalculateHashWithNonce(2))
}
